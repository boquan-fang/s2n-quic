// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

use rand_chacha::{
    rand_core::{block::BlockRng, RngCore, SeedableRng},
    ChaChaCore,
};

pub use s2n_quic_core::random::*;

// Number of generated bytes after which to reseed the public and private random
// generators.
//
// This value is based on THREAD_RNG_RESEED_THRESHOLD from
// [rand::rngs::thread.rs](https://github.com/rust-random/rand/blob/ef75e56cf5824d33c55622bf84a70ec6e22761ba/src/rngs/thread.rs#L39)
const RESEED_THRESHOLD: u64 = 1024 * 64;

struct AwsLc;

impl RngCore for AwsLc {
    #[inline]
    fn next_u32(&mut self) -> u32 {
        let mut v = [0; 4];
        self.fill_bytes(&mut v);
        u32::from_ne_bytes(v)
    }

    #[inline]
    fn next_u64(&mut self) -> u64 {
        let mut v = [0; 8];
        self.fill_bytes(&mut v);
        u64::from_ne_bytes(v)
    }

    #[inline]
    fn fill_bytes(&mut self, dest: &mut [u8]) {
        aws_lc_rs::rand::fill(dest).unwrap()
    }
}

/// A ChaCha-based RNG that periodically reseeds from AwsLc.
///
/// This replaces the removed `rand::rngs::ReseedingRng` with equivalent
/// functionality: a ChaCha CSPRNG that reseeds from `AwsLc` after
/// `RESEED_THRESHOLD` bytes have been generated.
struct ReseedingRng {
    inner: BlockRng<ChaChaCore>,
    bytes_until_reseed: u64,
}

impl ReseedingRng {
    fn new() -> Self {
        Self {
            inner: BlockRng::<ChaChaCore>::from_rng(&mut AwsLc),
            bytes_until_reseed: RESEED_THRESHOLD,
        }
    }

    #[inline]
    fn fill_bytes(&mut self, dest: &mut [u8]) {
        self.inner.fill_bytes(dest);
        let len = dest.len() as u64;
        self.bytes_until_reseed = self.bytes_until_reseed.saturating_sub(len);
        if self.bytes_until_reseed == 0 {
            self.inner = BlockRng::<ChaChaCore>::from_rng(&mut AwsLc);
            self.bytes_until_reseed = RESEED_THRESHOLD;
        }
    }
}

pub struct Random {
    public: ReseedingRng,
    private: ReseedingRng,
}

impl Default for Random {
    #[inline]
    fn default() -> Self {
        Self {
            public: ReseedingRng::new(),
            private: ReseedingRng::new(),
        }
    }
}

impl Generator for Random {
    #[inline]
    fn public_random_fill(&mut self, dest: &mut [u8]) {
        self.public.fill_bytes(dest);
    }

    #[inline]
    fn private_random_fill(&mut self, dest: &mut [u8]) {
        self.private.fill_bytes(dest);
    }
}
